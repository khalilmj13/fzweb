# -----------------------------------------------------------------------
#
#  Tokiwa Software GmbH, Germany
#
#  Source code of Fuzion webserver feature parse_value
#
# -----------------------------------------------------------------------

module parse_value(type_string String) is
  # Initialize type and parameters
  public typee := mut ""
  public parameters := (lock_free.map String String).empty


  # Recursive function to parse the key-value pairs in the string
  #
  parse_pairs(remaining_string String, r_parameters lock_free.map String String) lock_free.map String String =>
    match remaining_string.find "="
      nil => r_parameters
      eq i32 =>
        key := (remaining_string.substring 0 eq).trim
        rest_of_string := (remaining_string.substring (eq + 1)).trim

        # Handle quoted values
        if rest_of_string.starts_with "\""
          rest_of_string_trimmed := rest_of_string.substring 1
          quote := index_of rest_of_string_trimmed "\""

          match rest_of_string_trimmed.find "\""
            quote i32 =>
              value0 := rest_of_string_trimmed.substring 0 quote
              remaining_string_next := (rest_of_string_trimmed.substring (quote + 1)).trim
              r_parameters.add key value0
              parse_pairs remaining_string_next r_parameters
            nil =>
              value0 := rest_of_string_trimmed
              remaining_string_next := ""
              r_parameters.add key value0
              parse_pairs remaining_string_next r_parameters
        else
          match rest_of_string.find " "
            nil =>
              value0 := rest_of_string
              remaining_string_next := ""
              r_parameters.add key value0
              parse_pairs remaining_string_next r_parameters
            space i32 =>
              value0 := rest_of_string.substring 0 space
              remaining_string_next := (rest_of_string.substring (space + 1)).trim
              r_parameters.add key value0
              parse_pairs remaining_string_next r_parameters


  # Start parsing
  #
  match type_string.find ";"
    nil => typee <- type_string.trim
    semicolon i32 =>
      typee <- type_string.substring(0, semi).trim
      remaining_string := type_string.substring(semi + 1).trim
      _ := parse_pairs remaining_string parameters


  # return the type value
  #
  module get_type String =>
    typee.get


  # return the value of the boundary key in map "parameters" and empty string for false case
  #
  module get_boundary String =>
    val := parameters["boundary"].get ""
