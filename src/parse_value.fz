module parse_value(type_string String) is
  public typee := mut ""
  # Initialize type and parameters
  public parameters := (lock_free.map String String).empty

  # Helper function to find the index of a character in a string
  index_of(s String, c1 String) i32 =>
      res := s.find c1
      if res.is_nil
        -1
      else
        res.get

  # Recursive function to parse the key-value pairs in the string
  parse_pairs(remaining_string String, r_parameters lock_free.map String String) lock_free.map String String =>
    eq := index_of remaining_string "="
    if eq = -1
      r_parameters
    else
      key := remaining_string.substring(0, eq).trim
      rest_of_string := remaining_string.substring(eq + 1).trim

      # Handle quoted values
      if (index_of rest_of_string "\"") = 0
        rest_of_string_trimmed := rest_of_string.substring(1)
        quote := index_of rest_of_string_trimmed "\""

        if quote != -1
          value0 := rest_of_string_trimmed.substring 0 quote
          remaining_string_next := rest_of_string_trimmed.substring(quote + 1).trim
          r_parameters.add key value0
          parse_pairs remaining_string_next r_parameters

        else
          value0 := rest_of_string_trimmed
          remaining_string_next := ""
          r_parameters.add(key, value0)
          parse_pairs remaining_string_next r_parameters

      else
        space := index_of rest_of_string " "
        if space = -1
          value0 := rest_of_string
          remaining_string_next := ""
          r_parameters.add key value0
          parse_pairs remaining_string_next r_parameters

        else
          value0 := rest_of_string.substring 0 space
          remaining_string_next := rest_of_string.substring(space + 1).trim
          r_parameters.add key value0
          parse_pairs remaining_string_next r_parameters

  # Start parsing
  semi := index_of type_string ";"
  if semi < 0
    typee <- type_string.trim

  else
    typee <- type_string.substring(0, semi).trim
    remaining_string := type_string.substring(semi + 1).trim
    _ := parse_pairs remaining_string parameters

  # return the type value
  module get_type () String =>
    typee.get

  # return the value of the boundary key in map "parameters" and empty string for false case
  module get_boundary () String =>
    val := parameters["boundary"]
    if val.exists
      val
    else
      ""

